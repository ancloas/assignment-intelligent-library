from sqlalchemy import Column, Integer, String, ForeignKey, Float, Boolean
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.declarative import declarative_base, declared_attr
from werkzeug.security import generate_password_hash, check_password_hash
import re

Base = declarative_base()

class BaseModel:
    @declared_attr
    def __tablename__(cls):
        return cls.__name__.lower() + 's'

    def to_dict(self):
        """Convert model instance to dictionary."""
        return {column.name: getattr(self, column.name) for column in self.__table__.columns}

    @classmethod
    def from_dict(cls, data):
        """Create model instance from dictionary."""
        return cls(**data)
    

class User(Base, BaseModel):
    __tablename__ = "users"  # Explicitly declare table name

    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String, nullable=False, unique=True)  # Unique username for login
    password_hash = Column(String, nullable=False)  # Securely store hashed passwords
    email = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    is_admin = Column(Boolean, default=False)  # Flag for admin privileges

    # Establish a relationship to reviews with cascading deletion
    reviews = relationship("Review", back_populates="user", cascade="all, delete-orphan")

    def set_password(self, password: str):
        """Hash the password and store it in the password_hash column."""
        self.password_hash = generate_password_hash(password)

    def check_password(self, password: str) -> bool:
        """Check if the provided password matches the stored hashed password."""
        return check_password_hash(self.password_hash, password)
    
    @validates('username')
    def validate_username(self, key, username):
        """Ensure the username is not empty."""
        if not username:
            raise ValueError("Username cannot be empty.")
        return username

    @validates('email')
    def validate_email(self, key, email):
        """Ensure the email is valid using regex."""
        email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not email:
            raise ValueError("Email cannot be empty.")
        if not re.match(email_regex, email):
            raise ValueError("Invalid email format.")
        return email


class Book(Base, BaseModel):
    __tablename__ = "books"  # Explicitly declare table name

    id = Column(Integer, primary_key=True, autoincrement=True)
    title = Column(String, nullable=False)
    author = Column(String, nullable=False)
    genre = Column(String, nullable=False)
    year_published = Column(Integer)
    summary = Column(String)  # This can be generated by LLM

    # Establish a relationship to reviews with cascading deletion
    reviews = relationship("Review", back_populates="book", cascade="all, delete-orphan")
   

class Review(Base, BaseModel):
    __tablename__ = "reviews"  # Explicitly declare table name
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    book_id = Column(Integer, ForeignKey('books.id', ondelete="CASCADE"), nullable=False)
    user_id = Column(Integer, ForeignKey('users.id', ondelete="CASCADE"), nullable=False)
    review_text = Column(String, nullable=True)
    rating = Column(Float, nullable=False)

    # Back-populate relationships
    book = relationship("Book", back_populates="reviews")
    user = relationship("User", back_populates="reviews")
