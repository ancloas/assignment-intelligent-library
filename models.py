from sqlalchemy import Column, Integer, String, ForeignKey, Float, Boolean
from sqlalchemy.orm import relationship, validates
from sqlalchemy.ext.declarative import declarative_base, declared_attr
from werkzeug.security import generate_password_hash, check_password_hash
import re
from llm_utils import LLM_Base
from db_utils import DatabaseManager

Base = declarative_base()

class BaseModel:
    @declared_attr
    def __tablename__(cls):
        return cls.__name__.lower() + 's'

    def to_dict(self):
        """Convert model instance to dictionary."""
        return {column.name: getattr(self, column.name) for column in self.__table__.columns}

    @classmethod
    def from_dict(cls, data):
        """Create model instance from dictionary."""
        return cls(**data)
    

class User(Base, BaseModel):
    __tablename__ = "users"  # Explicitly declare table name

    id = Column(Integer, primary_key=True, autoincrement=True)
    username = Column(String, nullable=False, unique=True)  # Unique username for login
    password_hash = Column(String, nullable=False)  # Securely store hashed passwords
    email = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    is_admin = Column(Boolean, default=False)  # Flag for admin privileges

    # Establish a relationship to reviews with cascading deletion
    reviews = relationship("Review", back_populates="user", cascade="all, delete-orphan")

    def set_password(self, password: str):
        """Hash the password and store it in the password_hash column."""
        self.password_hash = generate_password_hash(password)

    def check_password(self, password: str) -> bool:
        """Check if the provided password matches the stored hashed password."""
        return check_password_hash(self.password_hash, password)
    
    @validates('username')
    def validate_username(self, key, username):
        """Ensure the username is not empty."""
        if not username:
            raise ValueError("Username cannot be empty.")
        return username

    @validates('email')
    def validate_email(self, key, email):
        """Ensure the email is valid using regex."""
        email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not email:
            raise ValueError("Email cannot be empty.")
        if not re.match(email_regex, email):
            raise ValueError("Invalid email format.")
        return email

class Book(Base, BaseModel):
    __tablename__ = "books"  # Explicitly declare table name

    id = Column(Integer, primary_key=True, autoincrement=True)
    title = Column(String, nullable=False)
    author = Column(String, nullable=False)
    genre = Column(String, nullable=False)
    year_published = Column(Integer)
    summary = Column(String)  # This can be generated by LLM

    # Establish a relationship to reviews with cascading deletion
    reviews = relationship("Review", back_populates="book", cascade="all, delete-orphan")
    
    def __init__(self, title, author, genre, year_published=None, summary=None):
        self.title = title
        self.author = author
        self.genre = genre
        self.year_published = year_published
        self.summary = summary

    async def generate_summary(self, llm_model: LLM_Base, db_manager: DatabaseManager):
        """Generate a book summary using an LLM model and update the book record."""
        user_query = f"""Summarize following book: \n"""
        if self.title:
            user_query += f"title: {self.title}\n"
        if self.author:
            user_query += f"Author: {self.author}\n"
        if self.year_published:
            user_query += f"Year Published: {self.year_published}\n"
        
        prompt = [
           {
               "role": "system",
               "content": (
                   "You are an expert book consultant with vast knowledge of literature and access to detailed book information. "
                   "Your task is to generate a concise and engaging summary of the book based on the provided details. "
                   "Focus on capturing the essence of the story, key themes, and significant aspects without including spoilers.\n\n"
               )
           },
           {
               "role": "user",
               "content": (
                   f"The book details are as follows:\n"
                   f"{user_query}\n\n"
                   "Please generate a summary that highlights the core storyline, major themes, and any unique features of the book."
               )
           }
        ]
       
               
        self.summary = await llm_model.generate_response(prompt)
        # Save or update the book record asynchronously
        await db_manager.add_or_save(self)
        
        return self.summary

class Review(Base, BaseModel):
    __tablename__ = "reviews"  # Explicitly declare table name
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    book_id = Column(Integer, ForeignKey('books.id', ondelete="CASCADE"), nullable=False)
    user_id = Column(Integer, ForeignKey('users.id', ondelete="CASCADE"), nullable=False)
    review_text = Column(String, nullable=True)
    rating = Column(Float, nullable=False)

    # Back-populate relationships
    book = relationship("Book", back_populates="reviews")
    user = relationship("User", back_populates="reviews")
